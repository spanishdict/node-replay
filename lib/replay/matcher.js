// Generated by CoffeeScript 1.9.2
var Matcher, URL, assert, jsStringEscape;

assert = require("assert");

URL = require("url");

jsStringEscape = require("js-string-escape");

Matcher = (function() {
  function Matcher(request, response) {
    var headers, name, ref, ref1, ref2, trailers, url, value;
    assert(request.url || request.regexp, "I need at least a URL to match request to response");
    if (request.regexp) {
      this.hostname = request.hostname;
      this.regexp = request.regexp;
    } else {
      url = URL.parse(request.url);
      this.hostname = url.hostname;
      this.port = url.port;
      this.path = url.path;
    }
    this.method = (request.method && request.method.toUpperCase()) || "GET";
    this.headers = {};
    if (request.headers) {
      ref = request.headers;
      for (name in ref) {
        value = ref[name];
        this.headers[name.toLowerCase()] = value;
      }
    }
    this.body = request.body;
    this.response = {
      version: response.version || "1.1",
      statusCode: response.statusCode && parseInt(response.statusCode, 10) || 200,
      statusMessage: response.statusMessage || "",
      headers: {},
      body: response.body.slice(0),
      trailers: {}
    };
    if (response.headers) {
      headers = this.response.headers;
      ref1 = response.headers;
      for (name in ref1) {
        value = ref1[name];
        headers[name.toLowerCase()] = value;
      }
    }
    if (response.trailers) {
      trailers = this.response.trailers;
      ref2 = response.trailers;
      for (name in ref2) {
        value = ref2[name];
        trailers[name.toLowerCase()] = value;
      }
    }
  }

  Matcher.prototype.match = function(request) {
    var body, chunks, data, headers, i, len, method, name, ref, url, value;
    url = request.url, method = request.method, headers = request.headers, body = request.body;
    if (this.hostname && this.hostname !== url.hostname) {
      return false;
    }
    if (this.regexp) {
      if (!this.regexp.test(url.path)) {
        return false;
      }
    } else {
      if (this.port && this.port !== url.port) {
        return false;
      }
      if (this.path && this.path !== url.path) {
        return false;
      }
    }
    if (this.method !== method) {
      return false;
    }
    ref = this.headers;
    for (name in ref) {
      value = ref[name];
      if (value !== headers[name]) {
        return false;
      }
    }
    if (body) {
      data = "";
      for (i = 0, len = body.length; i < len; i++) {
        chunks = body[i];
        data += chunks[0];
      }
      data = jsStringEscape(data);
      if (this.body && this.body !== data) {
        return false;
      }
    }
    return true;
  };

  Matcher.fromMapping = function(host, mapping) {
    var matcher, request;
    assert(!!mapping.path ^ !!mapping.request, "Mapping must specify path or request object");
    if (mapping.path) {
      request = {
        url: URL.resolve("http://" + host + "/", mapping.path),
        method: mapping.method
      };
    } else {
      if (mapping.request.url instanceof RegExp) {
        request = {
          host: host,
          regexp: mapping.request.url,
          method: mapping.request.method,
          headers: mapping.request.headers,
          body: mapping.request.body
        };
      } else {
        request = {
          url: URL.resolve("http://" + host, mapping.request.url),
          method: mapping.request.method,
          headers: mapping.request.headers,
          body: mapping.request.body
        };
      }
    }
    matcher = new Matcher(request, mapping.response || mapping);
    return function(request) {
      if (matcher.match(request)) {
        return matcher.response;
      }
    };
  };

  return Matcher;

})();

module.exports = Matcher;
