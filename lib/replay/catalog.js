// Generated by CoffeeScript 1.9.2
var Catalog, File, Matcher, Path, assert, debug, exists, existsSync, jsStringEscape, match, mkdir, parseHeaders, readAndInitialParseFile, writeHeaders,
  slice = [].slice;

assert = require("assert");

debug = require("./debug");

File = require("fs");

Path = require("path");

Matcher = require("./matcher");

jsStringEscape = require("js-string-escape");

exists = File.exists || Path.exists;

existsSync = File.existsSync || Path.existsSync;

existsSync = File.existsSync || Path.existsSync;

mkdir = function(pathname, callback) {
  return exists(pathname, function(found) {
    var parent;
    if (found) {
      callback(null);
      return;
    }
    parent = Path.dirname(pathname);
    return exists(parent, function(found) {
      if (found) {
        return File.mkdir(pathname, callback);
      } else {
        return mkdir(parent, function() {
          return File.mkdir(pathname, callback);
        });
      }
    });
  });
};

Catalog = (function() {
  function Catalog(settings) {
    this.settings = settings;
    this.matchers = {};
    this._basedir = Path.resolve("fixtures");
  }

  Catalog.prototype.getFixturesDir = function() {
    return this._basedir;
  };

  Catalog.prototype.setFixturesDir = function(dir) {
    this._basedir = Path.resolve(dir);
    this.matchers = {};
  };

  Catalog.prototype.find = function(host) {
    var base, base1, file, files, i, len, mapping, matchers, pathname, stat;
    matchers = this.matchers[host];
    if (matchers) {
      return matchers;
    }
    pathname = (this.getFixturesDir()) + "/" + (host.replace(":", "-"));
    if (!existsSync(pathname)) {
      pathname = (this.getFixturesDir()) + "/" + host;
    }
    if (!existsSync(pathname)) {
      return;
    }
    stat = File.statSync(pathname);
    if (stat.isDirectory()) {
      files = File.readdirSync(pathname);
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        matchers = (base = this.matchers)[host] || (base[host] = []);
        mapping = this._read(pathname + "/" + file);
        matchers.push(Matcher.fromMapping(host, mapping));
      }
    } else {
      matchers = (base1 = this.matchers)[host] || (base1[host] = []);
      mapping = this._read(pathname);
      matchers.push(Matcher.fromMapping(host, mapping));
    }
    return matchers;
  };

  Catalog.prototype.save = function(host, request, response, callback) {
    var base, matcher, matchers, pathname, request_headers, tmpfile, uid;
    matcher = Matcher.fromMapping(host, {
      request: request,
      response: response
    });
    matchers = (base = this.matchers)[host] || (base[host] = []);
    matchers.push(matcher);
    request_headers = this.settings.headers;
    uid = +(new Date) + "" + Math.floor(Math.random() * 100000);
    tmpfile = (this.getFixturesDir()) + "/node-replay." + uid;
    pathname = (this.getFixturesDir()) + "/" + (host.replace(":", "-"));
    debug("Creating " + pathname);
    return mkdir(pathname, function(error) {
      var body, chunks, file, filename, i, j, len, len1, part, ref, ref1;
      if (error) {
        return callback(error);
      }
      filename = pathname + "/" + uid;
      try {
        file = File.createWriteStream(tmpfile, {
          encoding: "utf-8"
        });
        file.write((request.method.toUpperCase()) + " " + (request.url.path || "/") + "\n");
        writeHeaders(file, request.headers, request_headers);
        if (request.body) {
          body = "";
          ref = request.body;
          for (i = 0, len = ref.length; i < len; i++) {
            chunks = ref[i];
            body += chunks[0];
          }
          writeHeaders(file, {
            body: jsStringEscape(body)
          });
        }
        file.write("\n");
        file.write("HTTP/" + (response.version || "1.1") + " " + (response.statusCode || 200) + " " + response.statusMessage + "\n");
        writeHeaders(file, response.headers);
        file.write("\n");
        ref1 = response.body;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          part = ref1[j];
          file.write(part[0], part[1]);
        }
        return file.end(function() {
          return File.rename(tmpfile, filename, callback);
        });
      } catch (_error) {
        error = _error;
        return callback(error);
      }
    });
  };

  Catalog.prototype._read = function(filename) {
    var body, parse_request, parse_response, part, ref, request, request_headers, response;
    request_headers = this.settings.headers;
    parse_request = function(request) {
      var _, body, flags, header_lines, headers, in_regexp, method, method_and_path, path, raw_regexp, ref, ref1, ref2, ref3, regexp;
      assert(request, filename + " missing request section");
      ref = request.split(/\n/), method_and_path = ref[0], header_lines = 2 <= ref.length ? slice.call(ref, 1) : [];
      if (/\sREGEXP\s/.test(method_and_path)) {
        ref1 = method_and_path.split(" REGEXP "), method = ref1[0], raw_regexp = ref1[1];
        ref2 = raw_regexp.match(/^\/(.+)\/(i|m|g)?$/), _ = ref2[0], in_regexp = ref2[1], flags = ref2[2];
        regexp = new RegExp(in_regexp, flags || "");
      } else {
        ref3 = method_and_path.split(/\s/), method = ref3[0], path = ref3[1];
      }
      assert(method && (path || regexp), filename + ": first line must be <method> <path>");
      assert(/^[a-zA-Z]+$/.test(method), filename + ": method not valid");
      headers = parseHeaders(filename, header_lines, request_headers);
      body = headers["body"];
      delete headers["body"];
      return {
        url: path || regexp,
        method: method,
        headers: headers,
        body: body
      };
    };
    parse_response = function(response, body) {
      var header_lines, headers, new_format, rawHeaders, ref, statusCode, statusMessage, status_line, version;
      if (response) {
        ref = response.split(/\n/), status_line = ref[0], header_lines = 2 <= ref.length ? slice.call(ref, 1) : [];
        new_format = status_line.match(/HTTP\/(\d\.\d)\s+(\d{3})\s*(.*)/);
        if (new_format) {
          version = new_format[1];
          statusCode = parseInt(new_format[2], 10);
          statusMessage = new_format[3].trim();
        } else {
          version = '1.1';
          statusCode = parseInt(status_line, 10);
        }
        headers = parseHeaders(filename, header_lines);
        rawHeaders = header_lines.reduce(function(raw, header) {
          var name, ref1, value;
          ref1 = header.split(/:\s+/), name = ref1[0], value = ref1[1];
          raw.push(name);
          raw.push(value);
          return raw;
        }, []);
      }
      return {
        statusCode: statusCode,
        statusMessage: statusMessage,
        version: version,
        headers: headers,
        rawHeaders: rawHeaders,
        body: body,
        trailers: {},
        rawTrailers: []
      };
    };
    ref = readAndInitialParseFile(filename), request = ref[0], response = ref[1], part = ref[2];
    body = [[part, void 0]];
    return {
      request: parse_request(request),
      response: parse_response(response, body)
    };
  };

  return Catalog;

})();

readAndInitialParseFile = function(filename) {
  var body, buffer, parts, parts0, parts1;
  buffer = File.readFileSync(filename);
  parts = buffer.toString('utf8').split('\n\n');
  if (parts.length > 2) {
    parts0 = new Buffer(parts[0], 'utf8');
    parts1 = new Buffer(parts[1], 'utf8');
    body = buffer.slice(parts0.length + parts1.length + 4);
  }
  return [parts[0], parts[1], body || ''];
};

parseHeaders = function(filename, header_lines, only) {
  var _, headers, i, key, len, line, name, ref, value;
  if (only == null) {
    only = null;
  }
  headers = Object.create(null);
  for (i = 0, len = header_lines.length; i < len; i++) {
    line = header_lines[i];
    if (line === "") {
      continue;
    }
    ref = line.match(/^(.*?)\:\s+(.*)$/), _ = ref[0], name = ref[1], value = ref[2];
    if (only && !match(name, only)) {
      continue;
    }
    key = (name || "").toLowerCase();
    value = (value || "").trim().replace(/^"(.*)"$/, "$1");
    if (Array.isArray(headers[key])) {
      headers[key].push(value);
    } else if (headers[key]) {
      headers[key] = [headers[key], value];
    } else {
      headers[key] = value;
    }
  }
  return headers;
};

writeHeaders = function(file, headers, only) {
  var item, name, results, value;
  if (only == null) {
    only = null;
  }
  results = [];
  for (name in headers) {
    value = headers[name];
    if (only && !match(name, only)) {
      continue;
    }
    if (Array.isArray(value)) {
      results.push((function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = value.length; i < len; i++) {
          item = value[i];
          results1.push(file.write(name + ": " + item + "\n"));
        }
        return results1;
      })());
    } else {
      results.push(file.write(name + ": " + value + "\n"));
    }
  }
  return results;
};

match = function(name, regexps) {
  var i, len, regexp;
  for (i = 0, len = regexps.length; i < len; i++) {
    regexp = regexps[i];
    if (regexp.test(name)) {
      return true;
    }
  }
  return false;
};

module.exports = Catalog;
